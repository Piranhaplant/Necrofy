using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Threading.Tasks;
using System.Threading;

namespace Necrofy
{
    public partial class Canvas : UserControl
    {
        public new event MouseEventHandler MouseDown;
        public new event MouseEventHandler MouseMove;
        public new event MouseEventHandler MouseUp;

        public bool IsMouseDown { get; set; } = false;
        private Point prevMousePosition = new Point(int.MinValue, int.MinValue);

        public Canvas() {
            InitializeComponent();
            base.MouseDown += Canvas_MouseDown;
            base.MouseMove += Canvas_MouseMove;
            base.MouseUp += Canvas_MouseUp;
            base.MouseLeave += Canvas_MouseLeave;
            base.Disposed += Canvas_Disposed;
        }

        private void Canvas_MouseDown(object sender, MouseEventArgs e) {
            IsMouseDown = true;
            MouseDown?.Invoke(sender, e);
        }

        private void Canvas_MouseMove(object sender, MouseEventArgs e) {
            // Used to ignore mouse move events that are generated by setting the property grid objects
            if (e.Location != prevMousePosition) {
                prevMousePosition = e.Location;
                MouseMove?.Invoke(sender, e);
            }
        }

        private void Canvas_MouseUp(object sender, MouseEventArgs e) {
            // Double clicking on the title bar to maximize the window causes mouse up events to be sent without a mouse down. This is used to ignore those.
            if (IsMouseDown) {
                IsMouseDown = false;
                MouseUp?.Invoke(sender, e);
            }
        }

        private void Canvas_MouseLeave(object sender, EventArgs e) {
            prevMousePosition = new Point(int.MinValue, int.MinValue);
        }

        public void GenerateMouseMove() {
            if (prevMousePosition.X != int.MinValue) {
                MouseMove?.Invoke(this, new MouseEventArgs(MouseButtons, 0, prevMousePosition.X, prevMousePosition.Y, 0));
            }
        }

        private CancellationTokenSource repaintCancel = new CancellationTokenSource();
        private bool timerRunning = false;
        private bool repaintQueued = false;

        public void Repaint() {
            repaintQueued = true;
            if (!timerRunning) {
                timerRunning = true;
                RepaintTimer(repaintCancel.Token);
            }
        }

        private async void RepaintTimer(CancellationToken cancellation) {
            while (!cancellation.IsCancellationRequested) {
                await Task.Delay(5);
                if (repaintQueued) {
                    Refresh();
                    repaintQueued = false;
                }
            }
        }

        private void Canvas_Disposed(object sender, EventArgs e) {
            repaintCancel.Cancel();
        }
    }
}
